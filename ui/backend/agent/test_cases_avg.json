{
    "subject": "Computer Programing",
    "number-of-questions": 3,
    "questions-schema": [
        {
            "question": "Explain the concept of recursion. Illustrate this by writing the code for calculating the factorial of a number.",
            "schema": [
                [
                    "The concept of recursion is clearly explained by the student.",
                    2
                ],
                [
                    "The code is syntax wise and logic wise correct",
                    2
                ]
            ],
            "total-score": 4,
            "relevant-theory": "Recursion is a fundamental programming concept where a function calls itself to solve a problem. Instead of using loops or iterative methods, recursion solves a problem by breaking it down into smaller subproblems of the same type. Each recursive call works on a reduced version of the original problem until it reaches a stopping condition, known as the base case.  \n\nThe base case is a condition that stops the recursive function from calling itself indefinitely. Without a base case, recursion would continue infinitely, leading to a stack overflow error. The recursive case is where the function calls itself with a modified argument that brings it closer to the base case.  \n\nWhen a recursive function is called, the execution of the current function is paused, and a new instance of the function is executed with a new parameter. These function calls are stored in the system\u2019s function call stack. When the base case is reached, the function starts returning results in a last in, first out order, meaning the most recent function call resolves first.  \n\nRecursion can be understood using the example of factorial calculation. Factorial is a mathematical operation that multiplies a number by all the positive integers less than it down to one. The recursive approach to factorial follows a structured pattern where the base case occurs when the number reaches zero, where the factorial of zero is defined as one. Otherwise, the function calls itself with the number reduced by one until it reaches the base case.  \n\nThe steps of recursive execution are as follows:  \n\n1. The function is called with an initial value.  \n2. If the value is zero, the function returns one, which serves as the base case.  \n3. Otherwise, the function calls itself with a reduced value.  \n4. This process continues until the base case is reached.  \n5. Once the base case is reached, the function starts returning values and resolves each previous function call in order.  \n\nRecursion has several advantages. It simplifies problem-solving by breaking down complex problems into smaller subproblems. It is useful for tree and graph traversals, such as depth-first search, and it provides an elegant and easier-to-understand approach for problems that have a natural recursive structure.  \n\nHowever, recursion also has disadvantages. It consumes more memory because each function call is stored in the call stack until the base case is reached. It can lead to stack overflow errors if the recursion depth is too large. It is also generally slower than iterative solutions because function calls and returns add overhead to execution time.  \n\nRecursive functions can be optimized in various ways. Tail recursion can be used to optimize recursion by ensuring that the recursive call is the last operation performed. Some compilers can optimize tail-recursive functions to avoid excessive memory usage. Memoization can be used to store previously computed results, preventing redundant calculations and improving efficiency.  \n\nRecursion is a powerful technique but should be used with caution to ensure optimal performance and avoid unnecessary memory consumption.",
            "student-answer": "Recursion is a method in programming where a function calls itself. It is mainly used for solving problems that involve repetition. A recursion function has a class defined in it that handles repitition using a for or while loop.\n\n\nIn recursion, there are two parts:  \n\n1. The repitition class, where the function handles repitition.\n2. The recursive case, where the function keeps calling itself until it reaches the base case.  \n\nFactorial of a number is the multiplication of all numbers from that number down to 1. Here is a recursive function to find the factorial of a number:  \n\n\ndef factorial(n):\n    return n * factorial(n - 1)  # Recursive case\n\nprint(factorial(5))\n\n\nIn the above code, the function keeps multiplying n with factorial(n-1). This continues until the function reaches the base case. For example, if we calculate factorial(5), it will call itself until it reaches factorial(0), at which point it will stop.  \n\nRecursion is useful for problems like factorial, Fibonacci series, and tree traversals. However, it takes up more memory because every function call is stored in memory."
        },
        {
            "question": "What are pointers in C++? Explain with an example how pointers are used to access array elements in C++. Also write a program to swap 2 numebrs using pointers in C++.",
            "schema": [
                [
                    "The student provided the correct meaning of the word pointer in terms of a programing language",
                    2.0
                ],
                [
                    "The student gave a correct explanation to the example of how can we access the elements of an array using pointers.",
                    1
                ],
                [
                    "The student used C++ language specifically to code for demonstrating how can we access the elements of an array using pointers",
                    1
                ],
                [
                    "The student wrote a syntax wise and logic wise correct C++ code for demonstrating how can we access the elements of an array using pointers",
                    2
                ],
                [
                    "The student wrote a code in C++ for swapping 2 numbers using pointers",
                    1
                ],
                [
                    "The student wrote a syntax wise and logic wise correct code for swapping 2 numbers using pointer",
                    2.0
                ]
            ],
            "total-score": 9,
            "relevant-theory": "Pointers in C++  \n\nPointers in C++ are special variables that store the memory addresses of other variables. Instead of holding actual data, a pointer holds the location in memory where the data is stored. Pointers are one of the most powerful features of C++ and are widely used in memory management, dynamic memory allocation, data structures, and function arguments.  \n\nWhy Use Pointers?  \n\n1. Efficient memory access: Direct memory access makes data manipulation faster, especially for large datasets.  \n2. Dynamic memory allocation: Pointers allow allocation and deallocation of memory during runtime.  \n3. Efficient function arguments: Instead of passing large objects by value (which copies data), pointers allow passing by reference.  \n4. Array and string manipulation: Since array names act as pointers, pointers make handling arrays and strings efficient.  \n5. Building data structures: Pointers are essential for implementing linked lists, trees, graphs, and other complex data structures.  \n\nKey Concepts of Pointers in C++  \n\n1. Declaring a pointer  \n   - A pointer is declared using the * symbol. The type of pointer must match the type of variable it points to.  \n   - Example:  \n     int *ptr;  // Pointer to an integer  \n     double *dptr;  // Pointer to a double  \n     char *cptr;  // Pointer to a character  \n\n2. Initializing a pointer  \n   - A pointer is assigned the address of a variable using the address-of (&) operator.  \n   - Example:  \n     int x = 10;  \n     int *ptr = &x; // ptr stores the address of x  \n\n3. Dereferencing a pointer  \n   - The dereference operator (*) is used to access the value stored at the address held by the pointer.  \n   - Example:  \n     int x = 10;  \n     int *ptr = &x;  \n\n     cout << *ptr;  // Outputs 10 (value at address stored in ptr)  \n\n4. Address-of operator (&)  \n   - The & operator returns the memory address of a variable.  \n   - Example:  \n     int x = 5;  \n     cout << &x;  // Outputs memory address of x  \n\n5. Null pointers  \n   - A pointer that does not point to any valid memory location is called a null pointer.  \n   - Example:  \n     int *ptr = nullptr;  // Pointer initialized to null  \n\n6. Pointers and arrays  \n   - In C++, the name of an array itself acts as a pointer to the first element of the array.  \n   - Example:  \n     int arr[] = {1, 2, 3, 4, 5};  \n     int *ptr = arr;  // ptr points to arr[0]  \n\n     cout << *ptr;  // Outputs 1 (value at arr[0])  \n\nUsing Pointers to Access Array Elements in C++  \n\nSince the array name is a pointer to the first element, pointer arithmetic can be used to access different elements of the array.  \n\nExample: Accessing elements using pointers  \n\n#include <iostream>  \nusing namespace std;  \n\nint main() {  \n    int arr[] = {10, 20, 30, 40, 50};  \n    int *ptr = arr;  // ptr points to arr[0]  \n\n    cout << \"Using pointers to access array elements: \" << endl;  \n    for (int i = 0; i < 5; i++) {  \n        cout << \"Element \" << i << \": \" << *(ptr + i) << endl;  \n    }  \n\n    return 0;  \n}  \n\nExplanation:  \n1. The pointer ptr is assigned the address of the first element of arr.  \n2. The loop iterates through the array elements using *(ptr + i).  \n3. *(ptr + i) accesses elements in the same way as arr[i].  \n\nPointer Arithmetic in Arrays  \n\nPointer arithmetic allows manipulation of pointers to navigate through arrays efficiently.  \n\n1. Incrementing a pointer (ptr++)  \n   - Moves the pointer to the next element in the array.  \n   - Example:  \n     int arr[] = {5, 10, 15};  \n     int *ptr = arr;  \n\n     ptr++;  // Moves pointer to the next element (arr[1])  \n     cout << *ptr; // Outputs 10  \n\n2. Decrementing a pointer (ptr--)  \n   - Moves the pointer to the previous element.  \n   - Example:  \n     ptr--;  // Moves pointer back to the previous element  \n\n3. Adding an integer to a pointer (ptr + n)  \n   - Moves the pointer forward by n positions.  \n   - Example:  \n     cout << *(ptr + 2); // Accesses arr[2]  \n\n4. Subtracting an integer from a pointer (ptr - n)  \n   - Moves the pointer backward by n positions.  \n   - Example:  \n     cout << *(ptr - 1); // Accesses arr[previous_index]  \n\nModifying Array Elements Using Pointers  \n\nPointers can be used to modify the elements of an array.  \n\nExample: Changing values using pointers  \n\n#include <iostream>  \nusing namespace std;  \n\nint main() {  \n    int arr[] = {1, 2, 3, 4, 5};  \n    int *ptr = arr;  \n\n    *ptr = 10;       // Changes arr[0] to 10  \n    *(ptr + 1) = 20; // Changes arr[1] to 20  \n\n    cout << \"Modified array: \";  \n    for (int i = 0; i < 5; i++) {  \n        cout << arr[i] << \" \";  \n    }  \n\n    return 0;  \n}  \n\nExplanation:  \n1. *ptr = 10; modifies the first element (arr[0]).  \n2. *(ptr + 1) = 20; modifies the second element (arr[1]).  \n\nPointers and Dynamic Arrays  \n\nPointers allow dynamic memory allocation, where memory is allocated during runtime.  \n\nExample: Dynamic array using pointers  \n\n#include <iostream>  \nusing namespace std;  \n\nint main() {  \n    int *arr = new int[5]; // Allocates memory for 5 integers  \n\n    for (int i = 0; i < 5; i++) {  \n        arr[i] = i * 10;  \n    }  \n\n    cout << \"Dynamic array elements: \";  \n    for (int i = 0; i < 5; i++) {  \n        cout << arr[i] << \" \";  \n    }  \n\n    delete[] arr; // Free allocated memory  \n\n    return 0;  \n}  \n\n\nSwapping Two Variables Using Pointers  \n\nPointers can be used to swap two variables by directly modifying their memory addresses. This is useful when passing arguments to functions by reference.  \n\nExample: Swapping two integers using pointers  \n\n#include <iostream>\nusing namespace std;\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    cout << \"Before swapping: x = \" << x << \", y = \" << y << endl;\n\n    swap(&x, &y); // Passing addresses to swap function\n\n    cout << \"After swapping: x = \" << x << \", y = \" << y << endl;\n    return 0;\n}\n\n\nExplanation:  \n1. The function `swap` takes two integer pointers as parameters.  \n2. The values stored at these memory locations are swapped using a temporary variable.  \n3. In `main`, the addresses of `x` and `y` are passed to `swap`, allowing direct modification of their values.  \n\nUsing pointers for swapping is efficient since it avoids copying large data structures and modifies values directly in memory.\n\n\nSummary  \n\n1. Pointers store the memory addresses of variables and allow direct memory manipulation.  \n2. The * operator is used to declare pointers and dereference them.  \n3. The & operator is used to obtain the address of a variable.  \n4. Array names act as pointers, and pointer arithmetic allows element access and modification.  \n5. Pointers enable dynamic memory allocation for flexible memory management.  \n\nPointers are a crucial feature in C++, enabling efficient programming and memory control. Proper use of pointers enhances performance but requires careful handling to avoid memory leaks and segmentation faults.",
            "student-answer": "Pointers are special variables in C++ that store values. They can also be used to store arrays. In this program, we have an array `arr` with values `{10, 20, 30, 40, 50}`. The pointer `ptr` is assigned the array, which means it stores the array itself.  \n\nA `for` loop is used to print the elements of the array. The loop runs from 1 to 5 and prints the elements using `*(ptr + i)`, which accesses the values. Since `ptr` is an array, we can also use `ptr[i]` instead. The program prints all elements correctly because `ptr + i` means moving to the next memory location and directly getting the values from the array.  \n\nThis method is useful because it allows printing an array without using indexing. However, arrays are already pointers, so using `ptr` is not necessary."
        },
        {
            "question": "What is Object Oriented Programming? Explain the four pillars of Object Oriented Programming and provide examples for each. Write codes to demonstrate each pillar.",
            "schema": [
                [
                    "The student should correctly define Object Oriented Programing.",
                    1
                ],
                [
                    "The student should name and define all the 4 pillars of Object Oriented Programming correctly.",
                    2
                ],
                [
                    "The student should be able to provide correct examples for all the 4 pillars of Object Oriented Programming correctly.",
                    2
                ]

            ],
            "total-score": 5,
            "relevant-theory": "Object-Oriented Programming (OOP) is a programming paradigm based on the concept of \"objects,\" which can contain data and methods to manipulate that data. It allows for better code organization, reusability, and scalability. OOP is used in many modern programming languages, including C++, Java, and Python.  \n\n Four Pillars of Object-Oriented Programming  \n\nOOP is based on four fundamental principles:  \n\n1. Encapsulation  \n2. Abstraction  \n3. Inheritance  \n4. Polymorphism  \n\n 1. Encapsulation  \nEncapsulation is the principle of bundling data (variables) and methods (functions) that operate on the data into a single unit called a class. It restricts direct access to some of an object's components, which helps prevent unintended modifications.  \n\nExample: Encapsulation in C++  \n```cpp\ninclude <iostream>\nusing namespace std;\n\nclass BankAccount {\nprivate:\n    double balance; // Private variable, cannot be accessed directly\n\npublic:\n    BankAccount(double initialBalance) { // Constructor\n        balance = initialBalance;\n    }\n\n    void deposit(double amount) { // Public method to add money\n        balance += amount;\n    }\n\n    void withdraw(double amount) { // Public method to withdraw money\n        if (amount <= balance) {\n            balance -= amount;\n        } else {\n            cout << \"Insufficient balance\" << endl;\n        }\n    }\n\n    double getBalance() { // Public method to access balance\n        return balance;\n    }\n};\n\nint main() {\n    BankAccount account(1000); // Create an object of BankAccount\n    account.deposit(500);\n    account.withdraw(300);\n    cout << \"Current Balance: \" << account.getBalance() << endl;\n    return 0;\n}\n```\nExplanation:  \n- The `balance` variable is private, so it cannot be accessed directly from outside the class.  \n- The `deposit`, `withdraw`, and `getBalance` methods allow controlled access to `balance`.  \n- Encapsulation ensures that `balance` cannot be modified directly, enforcing security.  \n\n 2. Abstraction  \nAbstraction is the process of hiding implementation details and exposing only necessary functionalities. It reduces complexity by allowing users to interact with an object without understanding its internal workings.  \n\nExample: Abstraction in C++  \n```cpp\ninclude <iostream>\nusing namespace std;\n\nclass Car {\npublic:\n    void start() { // Public method to start the car\n        igniteEngine();\n        accelerate();\n        cout << \"Car started\" << endl;\n    }\n\nprivate:\n    void igniteEngine() { // Internal function hidden from users\n        cout << \"Engine ignited\" << endl;\n    }\n\n    void accelerate() { // Internal function hidden from users\n        cout << \"Car accelerating\" << endl;\n    }\n};\n\nint main() {\n    Car myCar;\n    myCar.start(); // The user only calls start, not the internal methods\n    return 0;\n}\n```\nExplanation:  \n- The `start` method is public, while `igniteEngine` and `accelerate` are private.  \n- The user only needs to call `start`, without worrying about how the engine ignites or how acceleration works.  \n- This simplifies interaction with the `Car` class, making it easier to use.  \n\n 3. Inheritance  \nInheritance allows one class to derive properties and behaviors from another class. It promotes code reusability and a hierarchical relationship between classes.  \n\nExample: Inheritance in C++  \n```cpp\ninclude <iostream>\nusing namespace std;\n\nclass Animal {\npublic:\n    void eat() {\n        cout << \"This animal is eating\" << endl;\n    }\n};\n\nclass Dog : public Animal { // Dog class inherits from Animal\npublic:\n    void bark() {\n        cout << \"The dog is barking\" << endl;\n    }\n};\n\nint main() {\n    Dog myDog;\n    myDog.eat(); // Inherited from Animal\n    myDog.bark(); // Defined in Dog class\n    return 0;\n}\n```\nExplanation:  \n- The `Dog` class inherits from the `Animal` class.  \n- The `Dog` class can access the `eat` method from `Animal` without redefining it.  \n- This eliminates code duplication and allows the reuse of `Animal` class functionality.  \n\n 4. Polymorphism  \nPolymorphism allows methods to take different forms, enabling code flexibility and maintainability. It can be achieved through function overloading and method overriding.  \n\n Function Overloading (Compile-time Polymorphism)  \nFunction overloading allows multiple functions with the same name but different parameters.  \n\nExample: Function Overloading in C++  \n```cpp\ninclude <iostream>\nusing namespace std;\n\nclass MathOperations {\npublic:\n    int add(int a, int b) {\n        return a + b;\n    }\n\n    double add(double a, double b) {\n        return a + b;\n    }\n};\n\nint main() {\n    MathOperations math;\n    cout << \"Addition of integers: \" << math.add(5, 10) << endl;\n    cout << \"Addition of doubles: \" << math.add(5.5, 2.2) << endl;\n    return 0;\n}\n```\nExplanation:  \n- There are two `add` methods, one for integers and one for doubles.  \n- The compiler determines which method to call based on the arguments passed.  \n\n Method Overriding (Run-time Polymorphism)  \nMethod overriding allows a derived class to provide a specific implementation of a function that is already defined in its base class.  \n\nExample: Method Overriding in C++  \n```cpp\ninclude <iostream>\nusing namespace std;\n\nclass Animal {\npublic:\n    virtual void makeSound() { // Virtual function for overriding\n        cout << \"Animal makes a sound\" << endl;\n    }\n};\n\nclass Dog : public Animal {\npublic:\n    void makeSound() override { // Overriding base class method\n        cout << \"Dog barks\" << endl;\n    }\n};\n\nint main() {\n    Animal* animalPtr;\n    Dog myDog;\n    animalPtr = &myDog;\n    \n    animalPtr->makeSound(); // Calls Dog's overridden function due to polymorphism\n    return 0;\n}\n```\nExplanation:  \n- The `makeSound` function is declared as `virtual` in the base class.  \n- The `Dog` class overrides `makeSound` with its own implementation.  \n- The function call is determined at runtime, allowing different behaviors based on the object type.  \n\n Summary  \nObject-Oriented Programming (OOP) is a programming paradigm that improves code organization, reusability, and scalability. The four pillars of OOP are:  \n\n1. Encapsulation: Hides internal data and provides controlled access using public methods.  \n2. Abstraction: Hides implementation details and exposes only necessary functionalities.  \n3. Inheritance: Allows a class to inherit properties and behaviors from another class.  \n4. Polymorphism: Enables a single function or method to take multiple forms, increasing flexibility.  \n\nEach of these concepts plays a crucial role in making programs modular, maintainable, and efficient.",
            "student-answer": "Object-Oriented Programming (OOP) is a programming style that uses objects and classes to structure code. It helps in making code reusable and organized. OOP allows us to define classes that act as blueprints for creating objects. This way, instead of writing everything from scratch, we can reuse existing structures.  \n\nFour Pillars of Object-Oriented Programming  \n\n1. Encapsulation  \n   Encapsulation means keeping data safe from direct access by using private variables. It helps in securing data.  \n\n   cpp\n   class Student {\n   private:\n       int age;\n   public:\n       void setAge(int a) {\n           age = a;\n       }\n   };\n   \n\n2. Abstraction  \n   Abstraction means hiding the background details and showing only what is needed. It makes programming easier.  \n\n   cpp\n   class Vehicle {\n   public:\n       void start() {\n           cout << \"Vehicle is starting\" << endl;\n       }\n   };\n   \n\n\n3. Inheritance  \n   Inheritance allows a class to acquire properties from another class, reducing code repetition.  \n\n   cpp\n   class Parent {\n   public:\n       void show() {\n           cout << \"Parent class\" << endl;\n       }\n   };\n\n   class Child : private Parent {\n   public:\n       void display() {\n           show();\n       }\n   };\n   \n\n4. Polymorphism  \n   Polymorphism means using the same function name for different tasks. It can be achieved using function overloading.  \n\n   cpp\n   class Math {\n   public:\n       void add(int a, int b) {\n           cout << a + b << endl;\n       }\n       void add(float a, float b) {\n           cout << a + b << endl;\n       }\n   };\n   \n\nOverall, OOP is a very useful way to write code, as it organizes everything into objects and makes it reusable. The four pillars are important, but sometimes it is not necessary to use all of them in every program."
        }
    ]
}